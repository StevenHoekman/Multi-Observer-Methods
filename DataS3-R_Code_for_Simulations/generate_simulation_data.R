# generate_simulation_data.R
# Function for generating simulated survey data using multi-observer methods, version 1.2.1
# Steven T. Hoekman, Wild Ginger Consulting, PO Box 182 Langley, WA 98260, steven.hoekman@protonmail.com

# R computer code for generating simulated survey data for multi-observation method (MOM) and single-observation method (SOM) models. Accepts user-specified inputs for simulation analyses, returns list with 4 elements: 1) formatted simulated survey data, tables of key values (if applicable) for 2) observed groups and 3) binned covariate values, and 4) true values for mean overall true species probabilities and classification probabilities (if applicable). Code developed and tested in R version 4.1.

# This code should be executed prior to conducting simulation analyses in 'simulations_R_code.R'

###############################################################################
#           Function: {generate.simulation.data.f} 
###############################################################################

# This function accepts input of simulation profiles 'sim_profiles', with simulation inputs for each distinct model on a separate row. To generate simulated true survey data (true groups), random samples are drawn from appropriate probability distributions using true parameter values for: 

# (1) true species probabilities (psi)
# (2) species-specific mean group sizes (g)
# (3) heterogeneous group parameters (pi or rho) for each species pair

# From true survey data, observed groups matching target sample sizes for primary (n_p) and secondary (n_s) observers are generated by drawing random samples from multinomial distributions defined by true classification probabilities (theta) to classify individuals to observation states (a). 

# Function returns list 'dat' t comprised of elements:
# (1) Data frame 'survey_data' with simulated survey data consisting of observed groups for each survey observer, 'id' with integer value specifying simulation replicate, 'group' with group size, and a 'count' of identical observation histories. Included if applicable are values of predictive covariates and numeric key values for unique observed groups and covariate values. 
# (2) Optional data frame 'observed_group_key' with table of key values for unique observed groups
# (3) Optional data frame 'psi_key' with table of key values for unique values of a binned covariate predicting true species probabilities (psi) 
# (4) Optional vectors in 'mean_probability' with overall mean (across values of predictive covariates) true values for true species probabilities and classification probabilities 

generate.simulation.data.f <- function(sim) {  

###############################################################################
#                Import data and true parameters
###############################################################################

B <- sim$B; A <- sim$A # Number of true spp states (B) and observation states (A)
reps <- as.integer(sim$reps) # Number of simulation replicates
mix <- unlist(sim[grep("mix", colnames(sim))]) # Heterogeneous group probability parameters
mx.model <- sim$mx_model # Group probability model 
n_bins <- sim$n_bins # Number of bins for covariates
O_ps <- c(sim$O_p, sim$O_s) # Number of primary/secondary observers
n_obs <- sum(O_ps) # Total number of observers
g <- unlist(sim[grep("^g_[0123456789]", colnames(sim))]) # Columns defining group size
n.ps <- unlist(sim[grep("n_p|n_s", colnames(sim))]) # Target sample for primary/secondary observers

# Extract probabilities 'psi' or regression coefficients 'betas' for true species probabilities
if (length(grep("b0_psi.", colnames(sim))) == 0) {
  psi <- unlist(sim[grep("psi_", colnames(sim))])
  psi <- c(psi, 1 - sum(psi))
} else if (B == 2) {
  ndex <- grep("psi_1", colnames(sim))
  betas <- matrix(unlist(sim[ndex]), nrow = 1)
} else if (B == 3) {
  ndex <- grep("psi_1|psi_2", colnames(sim))
  betas <- matrix(unlist(sim[ndex]), nrow = 2, byrow = TRUE)
}
par.mean <- list(NULL, NULL)

# 'heterogeneity' = 1 indicates un-modeled heterogeneity in data arising from predictive covariate
if (length(grep("heterogeneity", colnames(sim))) > 0) {
  if (sim[grep("heterogeneity", colnames(sim))] == 1)
  unmodeled.covariate <- sim$heterogeneity
}

###############################################################################
#         Build matrices of classification probabilities
###############################################################################
  
## Build array 'theta.t' with matrices of true classification probabilities for each observer, except for models with regression coefficients influencing classification probabilities. If distinct classification probabilities not provided for each secondary observer, assume each is identical to first.

if (sim$Model == "M" | sim$Model == "M.theta.p" |  sim$Model == "mpX" | sim$Model == "M.psi") {
  col.n <- colnames(sim)
  theta.param <- list(
    sim[grep("theta_p", col.n)], sim[grep("theta_s1", col.n)], sim[grep("theta_s2", col.n)], sim[grep("theta_s3", col.n)], sim[grep("theta_s4", col.n)])
  tmp <- array(0, c(A - 1, B, sum(O_ps)))
  if (sim$Model == "M.theta.p") {
    theta.param[[1]] <- theta.param[[2]]
  }

  z <- 1
  for (i in 1:length(theta.param)) {
    if (dim(theta.param[[i]])[2] > 0) {
      tmp[, , z] <- unlist(theta.param[[i]])
      z <- z + 1
    }
  }
  
  if ((sum(tmp[, , O_ps[1] + 1]) != 0)) {
    for (i in 2:sum(O_ps)) {
      if (sum(tmp[, , i]) == 0) {
        tmp[, , i] <- tmp[, , i - 1]
      }
    }
  }

  theta.t <- vapply(1:sum(O_ps), theta4.f, matrix(0, B, A), tmp)
}

###############################################################################
# Group probabilities: No predictive covariate for true species probabilities
###############################################################################

## Compute group probabilities for models without covariate predicting true species probability (psi)

  if (length(grep("b0_psi.", colnames(sim))) == 0) {
    # Vector of multinomial group probabilities by spp with homogeneous groups 
    group.p <- (psi / g) / sum(psi / g)
    names(group.p) <- c(paste0("spp", 1:B))
  }

  # Group probabilities with heterogeneous groups
  if (any(mix > 0) & !grepl("psi", sim$Model)) {
    if (mx.model == "constant") {
      # Constant group probability model (described in eq. 7 in the companion article)
      if (B == 2) {
        # True species states = 2
        # Transform absolute parameter 'mix' to proportion of all groups that each species must contribute to mixed groups 'mix.g'
        mix.g <- mix / (1 + mix)
        # Check if heterogeneous group probability exceeds overall group probability for any species
        if (sum(group.p < mix.g) > 0) {
          # Adjust heterogeneous group parameter to maximum admissible value and print warning
          mix.g <-
            min(group.p[which(group.p < mix.g)])
          cat("Warning: mixing reduced to",
              mix.g / (1 - mix.g),
              "so least common species could contribute to groups proportionately"
          )
        }
        # Group probability vector for species 1 and 2 and for heterogeneous groups
        group.p <- c(c(group.p - mix.g, mix.g) / (1 - mix.g))
        col.mat <- matrix(c(1L, 1L), ncol = 1)
      } else if (B == 3) {
        # True species states = 3
        # Epsilon is total probability for heterogeneous groups of all species
        epsilon <- sum(mix)
        # Heterogeneous group species pairs
        pairs <- matrix(c(1, 2, 1, 3, 2, 3), 
                        ncol = 2, byrow = TRUE)
        spp.sum <- vapply(1:3, function(x)
          sum(mix[pairs[x, ]]), numeric(1))
        
        # Check if total heterogeneous group probability for a species exceeds its overall group probability
        test <- group.p - spp.sum / (1 + epsilon)
        if (any(test < 0)) {
          cat("mixing greater than group proportion for spp", which(test < 0))
        }
        # Vector with group probability for species 1 to 3 and heterogeneous group probabilities of 12, 13, 23
        group.p <- 
          c((group.p - spp.sum / (1 + epsilon)) / (1 - epsilon / (1 + epsilon)), mix)
        
        # 'col.mat' defines which species (columns) pairs are in which heterogeneous groups (rows) in 'group.p' vector
        col.mat <- matrix(c(
          1L, 1L, 0L, 1L, 0L, 1L, 0L, 1L, 1L), 
          B, choose(B, 2))
      }
    } 
    ## Alternative proportional mixing model
    # else if (mx.model == "pr") {
    #   # Proportional mixing model
    #   if (B == 2) {
    #     # True species states = 2
    #     mix.p <- group.p[1] * mix[1]
    #     # Group probability vector for species 1 and 2 and for heterogeneous groups
    #     group.p <- c(c(group.p - mix.p, mix.p) / (1 - mix.p))
    #     col.mat <- matrix(c(1L, 1L), ncol = 1)
    #   }else if (B == 3) {
    #     # True species states = 3
    #     # Enter the proportion of groups of a species (row) that form heterogeneous groups with another species (column), before accounting for group mixing
    #     mix.mat <- matrix(0, 3, 3)
    #     colnames(mix.mat) <- c(paste0("spp", 1:3))
    #     mix.mat[1, 2:3] <- mix[1:2]
    #     mix.mat[2, 3] <- mix[3]
    #     mix.mat[2, 1] <- mix.mat[1, 2] * group.p[1] / group.p[2]
    #     mix.mat[3, 1] <- mix.mat[1, 3] * group.p[1] / group.p[3]
    #     mix.mat[3, 2] <- mix.mat[2, 3] * group.p[2] / group.p[3]
    #     x <- 1:B
    # 
    #     # Express mixing as the absolute probability of each type of group among all groups. Probabilities for homogeneous groups of each species are on the diagonal.
    #     for (i in x) {
    #       mix.mat[i, i] <- 1 - sum(mix.mat[i, x[-i]])
    #       mix.mat[i, ] <- group.p[i] * mix.mat[i, ]
    #     }
    #     upper.mat <- c(mix.mat[1, 2:3], mix.mat[2, 3])
    #     # Group probability vector accounting for reduction in overall number of groups (because groups of 2 spp coalesce to form 1 group).
    #     group.p <- c(diag(mix.mat), upper.mat) / (1 - sum(upper.mat))
    # 
    #     # 'col.mat' defines which species (columns) pairs are in which heterogeneous groups (rows) in 'group.p' vector
    #     col.mat <- matrix(
    #       c(1L, 1L, 0L, 1L, 0L, 1L, 0L, 1L, 1L), 
    #       B, choose(B, 2))
    #   }
    # }
    names(group.p) <- 
      c(paste0("pi_", 1:B), "pi_12", "pi_13", "pi_23")[1:(B + choose(B, 2))]
  }
  
###############################################################################
#          Generate true survey data (including covariate predicting psi)
###############################################################################

## Generate data frame 'data.t' with true simulated survey data. First, draw random samples from multinomial group probabilities to generate homogeneous groups for each spp (and for heterogeneous groups), with columns for species 1 to B (and heterogeneous groups) and rows for each true group. Then, multiply groups containing each species by appropriate group sizes randomly drawn from group size probability mass distributions. List 'r' gives the # of group observations for each survey observer.

r <- list(y1 = n.ps[1] * reps, 
          y2 = n.ps[2] * reps)
r[3:5] <- rep(list(r$y2), 3)

# Surveys without covariate(s) predicting true species probability (psi)
if (sim$Model == "M" |
    sim$Model == "M.theta.p" |
    sim$Model == "M.theta" |
    sim$Model == "M.theta.ps" |
    sim$Model == "mpX") {
  
  data.t <- matrix(as.integer(rmnom(r[[1]], 1, prob = matrix(group.p, nrow = 1))),
                   ncol = length(group.p))
  
  # Surveys with covariate(s) predicting true species probability (psi)
} else if (sim$Model == "M.psi" |
           sim$Model == "M.theta.psi" |
           sim$Model == "M.theta+psi") {
  
  # Add standardized normal, group-level covariate
  covariate_psi <- rnorm(max(r[[1]], 1000000))

  # Create 'n_bins' equal-interval bins across range of covariate, with each bin taking value of the mean covariate value within that bin. Binning dramatically accelerates model optimization. 
  if (n_bins > 2 & n_bins < 51) {
    
    # For each covariate, create 'n_bin' equal-interval bins across range of values, with each bin taking mean value within that bin. 
    
    min_max <- colMinsMaxs(covariate_psi)
    bins <-
      seq(min_max[1], min_max[2] + 1e-10, length.out = (n_bins + 1))
    
    mean_bin <-
      binMeans(y = covariate_psi,
               x = covariate_psi,
               bx = bins)
    
    for (u in 1:n_bins) {
      covariate_psi[which(between(covariate_psi, bins[u], bins[u + 1]))] <-
        mean_bin[u]
    }
  }

  # 'psi.group' contains group probabilities for individual groups
  psi.group <- mlogit.regress.predict.f(covariate_psi, betas)
  
  # Group probabilities before accounting for heterogeneous groups
  if (any(g > 1)) {
    psi.group <- 
      transpose(transpose(psi.group) / g)
    
    psi.group <- psi.group / rowsums(psi.group)
  }
  colnames(psi.group) <- c(paste0("spp", 1:B))

  ## Group probabilities with covariates predicting true species probabilities (psi) and with heterogeneous groups
  if (any(mix > 0)) {
    if (mx.model == "constant") {
      # Constant group probability model (described in eq. 7 in the companion article)
      if (B == 2) {
        # True species states = 2
        # Transform absolute parameter 'mix' to proportion of all groups that each species must contribute to heterogeneous groups 'mix.g'.
        mix.g <- mix / (1 + mix)
        # Compute matrix with group probabilities (column) for each species 1 to B and heterogeneous group probabilities for groups with 2 spp, with rows for each true group
        psi.group <- cbind((psi.group - mix.g), mix.g) / (1 - mix.g)
        col.mat <- matrix(c(1L, 1L), ncol = 1)

        # Check if heterogeneous group probability exceeds overall group probability for any species, and reduce heterogeneous group probabilities as necessary
        if (any(psi.group < 0)) {
          negative.values <- which(psi.group < 0)
          cat("Warning: Mixing probability reduced because", length(negative.values), "probabilities of Psi for individual groups were <0")
          negative.rows <- negative.values %% dim(psi.group)[1]
          negative.rows[which(negative.rows == 0)] <- dim(psi.group)[1]
          psi.group[negative.rows, dim(psi.group)[2]] <-
            psi.group[negative.rows, dim(psi.group)[2]] + psi.group[negative.values]
          psi.group[negative.values] <- 0
        }
      } else if (B == 3) {
        # True species states = 3
        # Epsilon is total probability for heterogeneous groups of all species
        epsilon <- sum(mix)
        # Heterogeneous group species pairs
        pairs <- matrix(c(1, 2, 1, 3, 2, 3), 
                        ncol = 2, byrow = TRUE)
        spp.sum <-
          vapply(1:3, function(x)
            sum(mix[pairs[x,]]), numeric(1))
        
        # Check if heterogeneous group probability exceeds overall group probability for any species, if so reduce heterogeneous group probabilities to maximum admissible values
        test <- psi.group - spp.sum / (1 + epsilon)
        if (any(test < 0)) {
          xit <- 1
          repeat {
            diff.max <- which.min(test)
            r <- (sum(mix[pairs[diff.max, ]]) - (-test[diff.max] + 0.02)) / sum(mix[pairs[diff.max, ]])
            mix[pairs[diff.max, ]] <- mix[pairs[diff.max, ]] * max(r, 0)

            epsilon <- sum(mix)
            spp.sum <- vapply(1:3, function(x)
              sum(mix[pairs[x, ]]), numeric(1))
            test <- p - spp.sum / (1 + epsilon)
            if (all(test > 0)) break
            xit <- xit + 1
            if (xit > 10) break
          }
        }
        
        # Group probability matrix with columns for species 1 to 3 and for heterogeneous groups of 12, 13, 23, with rows for each true group
        psi.group <- cbind((psi.group - spp.sum / (1 + epsilon)) / (1 - epsilon / (1 + epsilon)),
                           matrix(mix, nrow = dim(psi.group)[1], ncol = B, byrow = TRUE))
        # 'col.mat' defines which species (columns) pairs are in which heterogeneous groups (rows) in 'psi.group' vector
        col.mat <- matrix(
          c(1L, 1L, 0L, 1L, 0L, 1L, 0L, 1L, 1L), B, choose(B, 2))
      }
    } else if (mx.model == "pr") {
      # Proportional mixing model
      if (B == 2) {
        # True species states = 2
        # Calculate true species probabilities using proportion of rarer species
        mix.psi <- mix[1] * pmin(psi.group[, 1], psi.group[, 2])
        # Calculate matrix with group probabilities (columns) for each species 1 to 3 and for heterogeneous groups, with rows for each true group
        psi.group <-  cbind(psi.group - mix.psi, mix.psi) / (1 - mix.psi)
        col.mat <- matrix(c(1L, 1L), ncol = 1)
      }else if (B == 3) {
        # True species states = 3
        # Matrix of absolute group probabilities (col) for each group (row)
        mix.mat <- 
          matrix(c(rep(0, B), mix), dim(psi.group)[1], 
                 B + choose(B, 2), byrow = TRUE) %>%
          setColnames(., c(paste0("spp", 1:B), "spp12", "spp13", "spp23"))
  
        pairs <- matrix(c(
          1, 2, 1, 3, 2, 3
          ), ncol = 2, byrow = TRUE)       
        
        mix.mat[, 1:B] <-
          vapply(1:B, function(x)
            1 - rowsums(mix.mat[, (pairs[x,] + B)]), numeric(dim(mix.mat)[1]))

        mix.mat[, 1:3] <- psi.group * mix.mat[, 1:3]
        mix.mat[, 4:6] <- psi.group[, c(1, 1, 2)] * mix.mat[, 4:6]

        psi.group <- mix.mat / 
          matrix(
            rep(rowsums(mix.mat), dim(mix.mat)[2]),
            ncol = dim(mix.mat)[2]
          )

        # 'col.mat' defines which species (columns) pairs are in which heterogeneous groups (rows) in vector 'psi.group'
        col.mat <- matrix(c(1L, 1L, 0L, 1L, 0L, 1L, 0L, 1L, 1L), 
                          B, choose(B, 2))
      }
    } else if (mx.model == "encounter") {
      # Uses "encounter" model for group-level group probabilities (described in the companion article in Appendix S3: Eqs. S3, S4)
      if (B == 2) {
        # True species states = 2
        # Absolute mixing probability for each group.
        mix.psi <- mix[1] * psi.group[, 1] * psi.group[, 2]
        
        # Calculate matrix with group probabilities (col) for each species and heterogeneous groups for each true group (row).
        psi.group <-  cbind(psi.group - mix.psi, mix.psi) / (1 - mix.psi)
        col.mat <- matrix(c(1L, 1L), ncol = 1)
      } else if (B == 3) {
        # True species states = 3
        # Matrix of absolute group probabilities (col) for each group (row)
        mix.mat <- 
          matrix(0, dim(psi.group)[1], 
                 B + choose(B, 2)) %>%
          setColnames(., c(paste0("spp", 1:3), "spp12", "spp13", "spp23"))
        
        pairs <- matrix(c(1, 2, 1, 3, 2, 3), 
                        ncol = 2, byrow = TRUE)
        
        # Group probabilities for heterogeneous groups
        mix.mat[, 4:6] <-
          vapply(1:3, function(x)
            mix[x] * psi.group[, pairs[x, 1]] * psi.group[, pairs[x, 2]],
            numeric(dim(mix.mat)[1]))
        
        # Group probabilities for homogeneous groups
        mix.mat[, 1:3] <-
          vapply(1:3, function(x)
            psi.group[, x] -
              rowsums(mix.mat[, B + pairs[x,]]),
            numeric(dim(mix.mat)[1]))
        
        # Group probability matrix with columns for species 1 to 3 and for heterogeneous groups of 12, 13, 23, with rows for each true group
        psi.group <- mix.mat / (1 - rowsums(mix.mat[, 4:6]))
        
        # 'col.mat' defines which species (columns) pairs are in which heterogeneous groups (rows) in vector 'psi.group'
        col.mat <- matrix(c(1L, 1L, 0L, 1L, 0L, 1L, 0L, 1L, 1L), 
                          B, choose(B, 2))
      }
    }
      colnames(psi.group) <- c(paste0("pi_", 1:B), "pi_12", "pi_13", "pi_23")[1:(B + choose(B, 2))]
  }

if (all(mix == 0)) {
  
  denom <- sum(vapply(1:dim(psi.group)[2], function(x)
    colmeans(psi.group)[x] * g[x], numeric(1))
  )
  
  psi.mean <- vapply(1:dim(psi.group)[2], function(x)
    (colMeans(psi.group)[x] * g[x]) / denom, numeric(1))
  
} else if (B == 2) {
  
  denom <- sum(vapply(1:B, function(x)
    colmeans(psi.group)[x] * g[x], numeric(1))) +
      colmeans(psi.group)[3] * sum(g)
  
  psi.mean <- c(
    (sum(colmeans(psi.group)[c(1, 3)]) * g[1]) / denom,
    (sum(colmeans(psi.group)[c(2, 3)]) * g[2]) / denom
  )
  
} else if (B == 3) {
  
  denom <- sum(vapply(1:B, function(x)
    colmeans(psi.group)[x] * g[x], numeric(1))) +
    colmeans(psi.group)[4] * sum(g[c(1, 2)]) + 
    colmeans(psi.group)[5] * sum(g[c(1, 3)]) +
    colmeans(psi.group)[6] * sum(g[c(2, 3)])
  
  psi.mean <- c(
    (sum(colmeans(psi.group)[c(1, 4, 5)]) * g[1]) / denom,
    (sum(colmeans(psi.group)[c(2, 4, 6)]) * g[2]) / denom,
    (sum(colmeans(psi.group)[c(3, 5, 6)]) * g[3]) / denom
  )
  
}
  names(psi.mean) <- c(paste0("psi_", 1:B))
  par.mean[[1]] <- psi.mean
  
  # Generate true groups from group probabilities 
  data.t <-
    matrix(as.integer(rmnom(r[[1]], 1, prob = psi.group[1:r[[1]], ])), 
           ncol = dim(psi.group)[2])
}

# With heterogeneous groups, add species pairs to columns for each species and remove columns for heterogeneous groups 
if (any(mix > 0)) { 
  
  data.t <- 
    vapply(1:B, function(b)
      as.integer(rowsums(data.t[, c(b, B + which(col.mat[b, ] == 1))])), 
      integer(dim(data.t)[1]))
}

# Add group sizes >=1 by random draws from appropriate probabilities mass for distribution of group sizes.
if (any(g > 1)) { 

  # Calculate lambda parameters for zero-truncated Poisson distribution
  lambda <- rep(0, length(g))
  lambda[which(g > 1)] <- vapply(g[which(g > 1)], function(x)
    optimize(ztpois.f, interval = c(0.000001, 100), size = x)$minimum, numeric(1))
  
  # Append group sizes to existing groups
  data.t <-
    data.t *
    vapply(1:B, function(b)
      as.integer(rtpois(r[[1]], lambda[b], a = 0)), 
      integer(r[[1]]))
  
}

###############################################################################
#     Generate simulated observed groups
###############################################################################

## Generate simulated classifications of true simulated survey data by randomly sampling from multinomial distributions using true classification probabilities (theta.t) for each survey observer. If theta matrices are not supplied for each secondary observer, assume each is identical to the first. 

# Create appropriate data frames for observations
# 'v' and 'y' are indices for keeping track of data columns associated with each observer
# 'y' is a list with each vector giving column numbers for a primary observer and 4 unique secondary observers
# 'v' is vector with each value giving columns numbers, ordered first by true species state 1 to B and then by observer within each species state. I.e, 1st col for species 1 and observer 1, 2nd col for species 1 and observer 2, etc. This index organizes list output from 'foreach' construct. 

v <- NULL
for (c.state in  1:A) {
  v <- c(v, seq.int(c.state, by = A, length.out = sum(O_ps)))
}

y <- list(
  y1 = 1:A, 
  y2 = (A + 1):(A * 2), 
  y3 = (A * 2 + 1):(A * 3), 
  y4 = (A * 3 + 1):(A * 4), 
  y5 = (A * 4 + 1):(A * 5)
  )

# Create data frame for simulated classifications
data.obs <- matrix(integer(r[[1]] * (sum(O_ps) * A)), 
                   ncol = sum(O_ps) * A )

## Generate simulated survey classifications for surveys without covariates influencing classification probabilities

if (sim$Model == "M" |
    sim$Model == "M.theta.p" |
    sim$Model == "mpX" |
    sim$Model == "M.psi") {
  
  i <- 1
  
  # For model 'M.theta.p', limit generation of classifications to secondary observers (classifications of primary observers are predicted by a covariate)
  if (sim$Model == "M.theta.p") {
    i <- O_ps[1] + 1
  }
  # Loops for spp and observers
  for (b in 1:B) {
    for (obs in i:sum(O_ps)) {
      # For observer 'obs', generate 'r' observed groups and place in columns 'y'. Observations are randomly generated for each individual in a true group by draws from a multinomial distribution with true classification probabilities 'theta.t'
      
      data.obs[1:r[[obs]], y[[obs]]] <-
        data.obs[1:r[[obs]], y[[obs]]] +
        matrix(as.integer(rmnom(
          length(data.t[1:r[[obs]], b]), data.t[1:r[[obs]], b], prob = matrix(theta.t[b, , obs], nrow = 1) )),
        ncol = A)
    }
  }
}

# Add column labels to survey classifications: 'y_p' and 'y_s' specify primary & secondary observers, and a suffix after an underscore designates observation states with integers 1 to B for each species and text 'p' for partial identification
colnames(data.obs) <- names.obs.f(B, A, O_ps)

###############################################################################
#     Generate survey classifications: Covariate(s) predicting thetas 
###############################################################################

## Generate simulated survey classifications with covariate influencing classification probabilities
 
if (sim$Model == "M.theta.p" |
    sim$Model == "M.theta" |
    sim$Model == "M.theta.psi" |
    sim$Model == "M.theta+psi" |
    sim$Model == "M.theta.ps") {
  # Add standardized normal, group-level covariate
  if (sim$Model == "M.theta+psi") {
    
    data.obs <- cbind(data.obs, 
                      covariate_theta = covariate_psi[1:dim(data.obs)[1]])
    
  }else if (sim$Model == "M.theta.ps"){
    
    # Vector 'covariate_theta_s' predicts classification probabilities (theta) only for secondary observers
    covariate_theta_s <- rnorm(dim(data.obs)[1], mean = 0 , sd = 1)
    
    # Create 'n_bins' equal-interval bins across range of covariate, with each bin taking value of the mean covariate value within that bin. Binning dramatically accelerates model optimization. 
    if (n_bins > 2 & n_bins < 51) {
      
      min_max <- colMinsMaxs(covariate_theta_s)
      bins <-
        seq(min_max[1], min_max[2] + 1e-10, length.out = (n_bins + 1))
      
      mean_bin <-
        binMeans(y = covariate_theta_s,
                 x = covariate_theta_s,
                 bx = bins)
      
      for (u in 1:n_bins) {
        covariate_theta_s[which(between(covariate_theta_s, bins[u], bins[u + 1]))] <-
          mean_bin[u]
      }
    }

    data.obs <- cbind(data.obs, 
                      covariate_theta_s = covariate_theta_s)
  }
  
  if (sim$Model == "M.theta.p" |
      sim$Model == "M.theta" |
      sim$Model == "M.theta.psi" | 
      sim$Model == "M.theta.ps") {
    
    # Vector 'covariate_theta' predicts classification probabilities (theta) for primary observers and for secondary observers when these share a common covariate
    covariate_theta <- rnorm(dim(data.obs)[1], mean = 0 , sd = 1)
    
    # Create 'n_bins' equal-interval bins across range of covariate, with each bin taking value of the mean covariate value within that bin. Binning dramatically accelerates model optimization. 
    if (n_bins > 2 & n_bins < 51) {
      
      min_max <- colMinsMaxs(covariate_theta)
      bins <-
        seq(min_max[1], min_max[2] + 1e-10, length.out = (n_bins + 1))
      
      mean_bin <-
        binMeans(y = covariate_theta,
                 x = covariate_theta,
                 bx = bins)
      
      for (u in 1:n_bins) {
        covariate_theta[which(between(covariate_theta, bins[u], bins[u + 1]))] <-
          mean_bin[u]
      }
    }
    
    data.obs <- cbind(data.obs, 
                      covariate_theta = covariate_theta)
  }

  theta.mean <- NULL

  if (B == 2 & A == 2) { ## ----- True species states = observation states = 2 -----
   
    ## Generate classifications for primary observers
    
    # 'betas' matrix summarizes regression coefficients for multinomial logistic regression predicting classification probabilities. Dimension 1 = observation states A and dimension 2 = regression coefficients (col 1 = intercepts, col 2 = slopes).

    if (O_ps[1] > 0)  {
      betas <- with(sim,
                    matrix(
                      c(b0_theta_p_21, b0_theta_p_12, b1_theta_p_21, b1_theta_p_12),
                      ncol = 2
                    ))
      
      # Loop for species
      for (b in 1:B) {
        
        # Generate true classification probabilities for each true group from group-level covariate values and regression coefficients
        prob.cov <-
          mlogit.regress.predict.f(data.obs[1:r[[1]], "covariate_theta"], betas[b, , drop = FALSE])[, (3 - b):b]
        
        # For observer 'obs', generate 'r' observed groups and place in columns 'y'. Classifications are generated for each individual using random draws from a multinomial distribution with true classification probabilities 'prob.cov' for each true group.
        data.obs[1:r[[1]], y[[1]]] <-
          data.obs[1:r[[1]], y[[1]]] +
          matrix(as.integer(rmnom(r[[1]], data.t[, b], prob = prob.cov[1:r[[1]], ])),
                 ncol = A)
      }
      
      theta.mean <-
        apply(betas, 1, function(x) mlogit.dist.f(x)[1, 1]) %>%
        setNames(., c("theta.p.21", "theta.p.12"))
      }
    
    ## Generate classifications for secondary observers
    
    # Skip data generation for model 'M.theta.p', because classification probabilities for secondary observers are not influenced by covariate.
    if (sim$Model == "M.theta" |
        sim$Model == "M.theta.psi" |
        sim$Model == "M.theta+psi" | 
        sim$Model == "M.theta.ps") {
      
      # 'betas' matrix summarizes regression coefficients for multinomial logistic regression predicting classification probabilities. Dimension 1 = observation states and dimension 2 = regression coefficients (col 1 = intercepts, col 2 = slopes).
      betas <- 
        with(sim,
             matrix(
               c(
                 b0_theta_s1_21, b0_theta_s1_12,
                 b1_theta_s1_21, b1_theta_s1_12
               ), 
               ncol = 2
             ))
      
      # Loop for species
      for (b in 1:B) {
        # Generate true classification probabilities for each true group from group-level covariate values and regression coefficients
        if (sim$Model == "M.theta.ps") {
          prob.cov <-
            mlogit.regress.predict.f(data.obs[1:r[[2]], "covariate_theta_s"], betas[b, , drop = FALSE])[, (3 - b):b]
        } else{
          prob.cov <-
            mlogit.regress.predict.f(data.obs[1:r[[2]], "covariate_theta"], betas[b, , drop = FALSE])[, (3 - b):b]
        }
        
        # Loop for observers
        for (obs in (O_ps[1] + 1):sum(O_ps)) {
          
          # For observer 'obs', generate 'r' observed groups and place in columns 'y'. Classifications are generated for each individual using random draws from a multinomial distribution with true classification probabilities 'prob.cov' for each true group.

          data.obs[1:r[[2]], y[[obs]]] <-
            data.obs[1:r[[2]], y[[obs]]] +
            matrix(as.integer(rmnom(r[[2]], data.t[1:r[[2]], b], prob = prob.cov[1:r[[2]], ])),
                   ncol = A)
        }
      }

      theta.mean <-
        c(theta.mean,
          apply(betas, 1, function(x) mlogit.dist.f(x)[1, 1])) %>%
        setNames(., c(names(theta.mean)[1:2], "theta.s1.21", "theta.s1.12"))
    }
  }  # Closure of B = 2, A = 2
    
 
  if (B == 2 & A == 3) { ## ----- True species states = 2, observation states = 3 -----
    
    ## Generate observations for primary observers
    
    # 'betas' array summarizes regression coefficients for multinomial logistic regression predicting classification probabilities. Dimension 1 = observation states, dimension 2 = regression coefficients (col 1 = intercepts, col 2 = slopes), dimension 3 = true species states.

    col.b <- list(c(3, 1, 2), c(1, 3, 2))
    
    if (O_ps[1] > 0)  {
      betas <- with(sim,
                    array(
                      c(
                        b0_theta_p_21, b0_theta_p_31, b1_theta_p_21, b1_theta_p_31,
                        b0_theta_p_12, b0_theta_p_32, b1_theta_p_12, b1_theta_p_32
                      ),
                      dim = c(2, 2, 2)
                    ))
      
    # Loop for spp
    for (b in 1:B) {
      # Generate true classification probabilities for each true group from group-level covariate values and regression coefficients
      prob.cov <- 
        mlogit.regress.predict.f(data.obs[1:r[[1]], "covariate_theta"], betas[, , b, drop = FALSE])[, col.b[[b]]]
      
      # For observer 'obs', generate 'r' observed groups and place in columns 'y'. Classifications are generated for each individual using random draws from a multinomial distribution with true classification probabilities 'prob.cov' for each true group.

      data.obs[1:r[[1]], y[[1]]] <-
        data.obs[1:r[[1]], y[[1]]] +
        matrix(as.integer(rmnom(r[[1]], data.t[, b], prob = prob.cov[1:r[[1]], ])), 
               ncol = A)
    }

    theta.mean <-
      sapply(1:2, function(z)
        mlogit.dist.f(betas[, , z])[1:2, 1]) %>%
      setColnames(., c("theta.p.1", "theta.p.2"))
    }
    
    ## Generate observations for secondary observers
    
    # Skip data generation for model 'M.theta.p', because classification probabilities for secondary observers are not influenced by covariate.
    if (sim$Model == "M.theta" |
        sim$Model == "M.theta.psi" |
        sim$Model == "M.theta.ps") {
      
      # 'betas' array summarizes regression coefficients for multinomial logistic regression predicting classification probabilities. Dimension 1 = observation states, dimension 2 = regression coefficients (col 1 = intercepts, col 2 = slopes), dimension 3 = true species states.
      
      betas <- with(sim,
                    array(c(
                      b0_theta_s1_21, b0_theta_s1_31, b1_theta_s1_21, b1_theta_s1_31,
                      b0_theta_s1_12, b0_theta_s1_32, b1_theta_s1_12, b1_theta_s1_32
                    ),
                    dim = c(2, 2, 2)
                    ))
      
      # Loop for species
      for (b in 1:B) {
        # Generate true classification probabilities for each true group from group-level covariate values and regression coefficients
        if (sim$Model == "M.theta.ps") {
          prob.cov <-
            mlogit.regress.predict.f(data.obs[1:r[[2]], "covariate_theta_s"], betas[, , b, drop = FALSE])[, col.b[[b]]]
        } else{
          prob.cov <-
            mlogit.regress.predict.f(data.obs[1:r[[2]], "covariate_theta"], betas[, , b, drop = FALSE])[, col.b[[b]]]
        }
        
      # Loop for observer
      for (obs in (O_ps[1] + 1):sum(O_ps)) {
        
        # For observer 'obs', generate 'r' observed groups and place in columns 'y'. Classifications are generated for each individual using random draws from a multinomial distribution with true classification probabilities 'prob.cov' for each true group.
        
        data.obs[1:r[[2]], y[[obs]]] <-
          data.obs[1:r[[2]], y[[obs]]] +
          matrix(as.integer(rmnom(r[[2]], data.t[1:r[[2]], b], prob = prob.cov[1:r[[2]], ])), 
                 ncol = A)
        }
      }
      theta.mean <-
        cbind(theta.mean,
          sapply(1:2, function(z)
            mlogit.dist.f(betas[, , z])[1:2, 1])) %>%
        setColnames(., c(colnames(theta.mean)[1:2], "theta.s1.1", "theta.s1.2"))
    }  
  } # Closure of B = 2, A = 3
  
  if (B == 3 & A == 3) { ##  ----- True species states = observation states = 3 -----
   
    ## Generate observations for primary observers
    
    # 'betas' matrix summarizes regression coefficients for multinomial logistic regression predicting classification probabilities. Dimension 1 = observation states, dimension 2 = regression coefficients (col 1 = intercepts, col 2 = slopes), dimension 3 = true species states.
    
    col.b <- list(c(3, 1, 2), c(1, 3, 2), c(1, 2, 3))
    
    if (O_ps[1] > 0)  {
    betas <- with(sim,
                  array(c(
                    b0_theta_p_21, b0_theta_p_31, b1_theta_p_21, b1_theta_p_31,	
                    b0_theta_p_12, b0_theta_p_32, b1_theta_p_12, b1_theta_p_32,	
                    b0_theta_p_13, b0_theta_p_23, b1_theta_p_13, b1_theta_p_23
                  ),
                  dim = c(2, 2, 3)
                  ))
   
    
    # Loop for species
    for (b in 1:B) {
      # Generate true classification probabilities for each true group from group-level covariate values and regression coefficients
      prob.cov <- 
        mlogit.regress.predict.f(data.obs[1:r[[1]], "covariate_theta"], betas[, , b, drop = FALSE])[, col.b[[b]]]
      
      # For observer 'obs', generate 'r' observed groups and place in columns 'y'. Classifications are generated for each individual using random draws from a multinomial distribution with true classification probabilities 'prob.cov' for each true group.
      
      data.obs[1:r[[1]], y[[1]]] <-
        data.obs[1:r[[1]], y[[1]]] +
        matrix(as.integer(rmnom(r[[1]], data.t[, b], prob = prob.cov[1:r[[1]], ])), 
               ncol = A)
    }

    theta.mean <-
      sapply(1:3, function(z)
        mlogit.dist.f(betas[, , z])[1:2, 1])
    colnames(theta.mean) <- c("theta.p.1", "theta.p.2", "theta.p.3")
    }
    
    ## Generate observations for secondary observers
    
    # Skip data generation for model 'M.theta.p', because classification probabilities for secondary observers not influenced by covariate.
    if (sim$Model == "M.theta" |
        sim$Model == "M.theta.psi" | 
        sim$Model == "M.theta.ps") {
      
      # 'betas' matrix summarizes regression coefficients for multinomial logistic regression predicting classification probabilities. Dimension 1 = observation states, dimension 2 = regression coefficients (col 1 = intercepts, col 2 = slopes), dimension 3 = true species states.
      
      betas <- with(sim,
                    array(c(
                      b0_theta_s1_21, b0_theta_s1_31, b1_theta_s1_21, b1_theta_s1_31,	
                      b0_theta_s1_12, b0_theta_s1_32, b1_theta_s1_12, b1_theta_s1_32,	
                      b0_theta_s1_13, b0_theta_s1_23, b1_theta_s1_13, b1_theta_s1_23
                    ),
                    dim = c(2, 2, 3)
                    ))
      
      # Loop for species
      for (b in 1:B) {
        # Generate true classification probabilities for each true group from group-level covariate values and regression coefficients
        if (sim$Model == "M.theta.ps") {
          prob.cov <-
            mlogit.regress.predict.f(data.obs[1:r[[1]], "covariate_theta_s"], betas[, , b, drop = FALSE])[, col.b[[b]]]
        } else{
          prob.cov <-
            mlogit.regress.predict.f(data.obs[1:r[[1]], "covariate_theta"], betas[, , b, drop = FALSE])[, col.b[[b]]]
        }
        
        # Loop for observer
        for (obs in (O_ps[1] + 1):sum(O_ps)) {
          
          # For observer 'obs', generate 'r' observed groups and place in columns 'y'. Classifications are generated for each individual using random draws from a multinomial distribution with true classification probabilities 'prob.cov' for each true group.
          
          data.obs[1:r[[2]], y[[obs]]] <-
            data.obs[1:r[[2]], y[[obs]]] +
            matrix(as.integer(rmnom(r[[2]], data.t[1:r[[2]], b], prob = prob.cov[1:r[[2]], ])), 
                   ncol = A)
        }
      }
      theta.mean <-
        cbind(theta.mean,
              sapply(1:3, function(z)
                mlogit.dist.f(betas[, , z])[1:2, 1])) %>%
        setColnames(., c(colnames(theta.mean)[1:3], "theta_s1_1", "theta_s1_2", "theta_s1_3"))
      
    }
  } # Closure of B = 3, A = 3
par.mean[[2]] <- theta.mean
  
  } # Closure of model M.theta

###############################################################################
#               Format and export 
###############################################################################

if (is.matrix(data.obs)) data.obs <- qTBL(data.obs)

## Add additional fields to simulated survey data

# Add 'covariate_psi' predicting true species probabilities (psi) to simulated survey data, if needed
if ((sim$Model == "M.psi" |
     sim$Model == "M.theta.psi" |
     sim$Model == "M.theta+psi") &
    !exists("unmodeled.covariate", inherits = FALSE)) {
  
  settransform(data.obs, "covariate_psi" = covariate_psi[1:r[[1]]])
  
} else if ((exists("unmodeled.covariate", inherits = FALSE)) &
           any(colnames(data.obs) == "covariate_theta")) {
  
  # For statistical analyses including un-modeled heterogeneity in data (arising from covariates predicting true species probabilities or classification probabilities), remove covariate columns
  settransform(data.obs, "covariate_theta" = NULL)
}

# Add 'group_size' with total size of each true group, id' indexing simulation replicates
settransform(data.obs, 
             group_size = rowsums(qM(get_vars(data.obs, 1:A))), 
             id = rep(1:reps, n.ps[1]))

# Format simulated observations for statistical analyses (see format.MOM.data.f in 'supplemental_functions.R'), and return formatted simulated survey data
dat <- format.MOM.data.f(data.obs, 
                         A, 
                         O_ps, 
                         mix, 
                         n_bins)

dat[[4]] <- par.mean
names(dat) <- list("survey_data", "observed_group_key", "psi_key", "mean_probability")
names(dat[[4]]) <- c("psi", "theta")
dat
}
